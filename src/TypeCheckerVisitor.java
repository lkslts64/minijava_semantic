package myvisitors;

//
// Generated by JTB 1.3.2 DIT@UoA patched
//

import symboltable.ClassScope;
import visitor.GJDepthFirst;
import symboltable.FuncSignature;
import symboltable.Scope;
import symboltable.SymbolTable;
import syntaxtree.*;
import java.util.*;

/**
 * Provides default methods which visit each node in the tree in depth-first
 * order.  Your visitors may extend this class.
 */
public class  TypeCheckerVisitor extends GJDepthFirst<String, Scope> {

    public String visit(NodeToken n, Scope argu) { return n.tokenImage; }

    //
    // User-generated visitor methods below
    //

    private SymbolTable sym;
    private boolean error;
    //holds the scope of a function being called and pops it when we are done with the parsing of the call
    //we use a stack and not a single variable because we can have nested function calls.
    private Deque<PairIntScope> scopeStack;

    public TypeCheckerVisitor(SymbolTable sym) {
        this.sym = sym;
        scopeStack = new ArrayDeque<>();
        error = false;
    }

    public void printErrMsg(String err) {
        System.out.println(err);
        error = true;
    }

    /**
     * f0 -> MainClass()
     * f1 -> ( TypeDeclaration() )*
     * f2 -> <EOF>
     */
    public String visit(Goal n, Scope argu) {
        String _ret=null;
        n.f0.accept(this, argu);
        n.f1.accept(this, argu);
        n.f2.accept(this, argu);
        if (!scopeStack.isEmpty())
            System.out.println("PANIC. finished stack not empty");
        if (this.error == true)
            return "ERROR";
        return "OK";
    }

    /**
     * f0 -> "class"
     * f1 -> Identifier()
     * f2 -> "{"
     * f3 -> "public"
     * f4 -> "static"
     * f5 -> "void"
     * f6 -> "main"
     * f7 -> "("
     * f8 -> "String"
     * f9 -> "["
     * f10 -> "]"
     * f11 -> Identifier()
     * f12 -> ")"
     * f13 -> "{"
     * f14 -> ( VarDeclaration() )*
     * f15 -> ( Statement() )*
     * f16 -> "}"
     * f17 -> "}"
     */
    //argu=null here.
    public String visit(MainClass n, Scope argu) {
        String _ret=null;
        //just pass the scope of main to (statements)* ...
        Scope scope = sym.getFuncHash(n.f6.accept(this,argu),n.f1.accept(this,argu));
        n.f15.accept(this, scope);
        return _ret;
    }

    /**
     * f0 -> ClassDeclaration()
     *       | ClassExtendsDeclaration()
     */
    public String visit(TypeDeclaration n, Scope argu) {
        return n.f0.accept(this, argu);
    }

    /**
     * f0 -> "class"
     * f1 -> Identifier()
     * f2 -> "{"
     * f3 -> ( VarDeclaration() )*
     * f4 -> ( MethodDeclaration() )*
     * f5 -> "}"
     */
    //argu is null here.
    public String visit(ClassDeclaration n, Scope argu) {
        String _ret=null;
        ClassScope classScope = sym.getClassHash(n.f1.accept(this, argu));
        if ( classScope == null) {
            System.out.println("PANIC.Class doesn't exist.");
        }
        n.f4.accept(this, classScope);
        return _ret;
    }

    /**
     * f0 -> "class"
     * f1 -> Identifier()
     * f2 -> "extends"
     * f3 -> Identifier()
     * f4 -> "{"
     * f5 -> ( VarDeclaration() )*
     * f6 -> ( MethodDeclaration() )*
     * f7 -> "}"
     */
    //argu is null here.
    public String visit(ClassExtendsDeclaration n, Scope argu) {
        String _ret=null;
        n.f0.accept(this, argu);
        ClassScope classScope = sym.getClassHash(n.f1.accept(this, argu));
        if ( classScope == null) {
            System.out.println("PANIC.Class doesn't exist.");
        }
        n.f6.accept(this, classScope);
        return _ret;
    }

    /**
     * f0 -> "public"
     * f1 -> Type()
     * f2 -> Identifier()
     * f3 -> "("
     * f4 -> ( FormalParameterList() )?
     * f5 -> ")"
     * f6 -> "{"
     * f7 -> ( VarDeclaration() )*
     * f8 -> ( Statement() )*
     * f9 -> "return"
     * f10 -> Expression()
     * f11 -> ";"
     * f12 -> "}"
     */
    public String visit(MethodDeclaration n, Scope argu) {
        String _ret=null;
        //Scope scope = sym.getFuncHash(n.f2.accept(this, argu),argu.getName());
        String fn = n.f2.accept(this,null);
        Scope scope = sym.getFuncHash(fn,argu.getName());
        n.f8.accept(this, scope);
        String ret_type = n.f10.accept(this,scope);
        String sign_ret_type = sym.getFuncSignature(scope).getReturnType();
        if (ret_type == null || (!sign_ret_type.equals(ret_type) && !(sym.checkSubType(sign_ret_type,ret_type))))
            printErrMsg(">Error: Not matched return types in function " + fn );
        return _ret;
    }

    /**
     * f0 -> ArrayType()
     *       | BooleanType()
     *       | IntegerType()
     *       | Identifier()
     */
    public String visit(Type n, Scope argu) {
        return n.f0.accept(this, argu);
    }

    /**
     * f0 -> "int"
     * f1 -> "["
     * f2 -> "]"
     */
    public String visit(ArrayType n, Scope argu) {
        return n.f0.accept(this, argu) + n.f1.accept(this, argu) + n.f2.accept(this, argu);
    }

    /**
     * f0 -> Identifier()
     * f1 -> "="
     * f2 -> Expression()
     * f3 -> ";"
     */
    public String visit(AssignmentStatement n, Scope argu) {
        String _ret=null;
        String type = n.f0.accept(this, argu);
        if ( type  == null) {
            return _ret;
        }
        String expr_type = n.f2.accept(this,argu);
        //System.out.println(expr_type + type);
        if (expr_type == null || (!type.equals(expr_type) && !(sym.checkSubType(type,expr_type)))) {
            printErrMsg(">Error: Different types in AssignmentStatement");
        }
        return _ret;
    }

    /**
     * f0 -> Identifier()
     * f1 -> "["
     * f2 -> Expression()
     * f3 -> "]"
     * f4 -> "="
     * f5 -> Expression()
     * f6 -> ";"
     */
    public String visit(ArrayAssignmentStatement n, Scope argu) {
        String _ret=null;
        String type = n.f0.accept(this, argu);
        if ( type  == null) {
            return _ret;
        }
        if ( !type.equals("int[]"))
            printErrMsg(">Error: Expected int[] type in ArrayAssignmentStmt");
        if ( !n.f2.accept(this, argu).equals("int")) {
            printErrMsg(">Error: offset of array should be of type int");
        }
        if ( !n.f5.accept(this, argu).equals("int")) {
            printErrMsg(">Error: RHS of ArrayAssignmentStatement should be of type int");
        }
        return _ret;
    }

    /**
     * f0 -> "if"
     * f1 -> "("
     * f2 -> Expression()
     * f3 -> ")"
     * f4 -> Statement()
     * f5 -> "else"
     * f6 -> Statement()
     */
    public String visit(IfStatement n, Scope argu) {
        String _ret=null;
        if (!n.f2.accept(this, argu).equals("boolean") ) {
            printErrMsg(">Error:Condition in if statement should be of type boolean");
        }
        n.f4.accept(this, argu);
        n.f6.accept(this, argu);
        return _ret;
    }

    /**
     * f0 -> "while"
     * f1 -> "("
     * f2 -> Expression()
     * f3 -> ")"
     * f4 -> Statement()
     */
    public String visit(WhileStatement n, Scope argu) {
        String _ret=null;
        if ( !n.f2.accept(this, argu).equals("boolean")) {
            printErrMsg(">Error:Condition in while statement should be of type boolean");
        }
        n.f4.accept(this, argu);
        return _ret;
    }

    /**
     * f0 -> "System.out.println"
     * f1 -> "("
     * f2 -> Expression()
     * f3 -> ")"
     * f4 -> ";"
     */
    public String visit(PrintStatement n, Scope argu) {
        String _ret=null;
        String expr_type = n.f2.accept(this,argu);
        if ( !expr_type.equals("int") && !expr_type.equals("boolean"))
            printErrMsg(">Error: Not compatible type in System.out.println()");
        return _ret;
    }

    /**
     * f0 -> Clause()
     * f1 -> "&&"
     * f2 -> Clause()
     */
    public String visit(AndExpression n, Scope argu) {
        if ( !n.f0.accept(this, argu).equals("boolean") || !n.f2.accept(this, argu).equals("boolean")) {
            printErrMsg(">Error: At least one operand in AndExpression is not of type boolean");
        }
        return "boolean";
    }

    /**
     * f0 -> PrimaryExpression()
     * f1 -> "<"
     * f2 -> PrimaryExpression()
     */
    public String visit(CompareExpression n, Scope argu) {
        if ( !n.f0.accept(this, argu).equals("int") || !n.f2.accept(this, argu).equals("int"))
            printErrMsg(">Error: At least one operand in CompareExpression is not of type int");
        return "boolean";
    }

    /**
     * f0 -> PrimaryExpression()
     * f1 -> "+"
     * f2 -> PrimaryExpression()
     */
    public String visit(PlusExpression n, Scope argu) {
        if ( !n.f0.accept(this, argu).equals("int")  || !n.f2.accept(this, argu).equals("int") )
            printErrMsg(">Error: At least one operand in PlusExpression is not of type int");
        return "int";
    }

    /**
     * f0 -> PrimaryExpression()
     * f1 -> "-"
     * f2 -> PrimaryExpression()
     */
    public String visit(MinusExpression n, Scope argu) {
        if ( !n.f0.accept(this, argu).equals("int")  || !n.f2.accept(this, argu).equals("int") )
            printErrMsg(">Error: At least one operand in MinusExpression is not of type int");
        return "int";
    }

    /**
     * f0 -> PrimaryExpression()
     * f1 -> "*"
     * f2 -> PrimaryExpression()
     */
    public String visit(TimesExpression n, Scope argu) {
        if ( !n.f0.accept(this, argu).equals("int")  || !n.f2.accept(this, argu).equals("int") )
            printErrMsg(">Error: At least one operand in TimesExpression is not of type int");
        return "int";
    }

    /**
     * f0 -> PrimaryExpression()
     * f1 -> "["
     * f2 -> PrimaryExpression()
     * f3 -> "]"
     */
    public String visit(ArrayLookup n, Scope argu) {
        String _ret=null;
        if ( !n.f0.accept(this, argu).equals("int[]"))
            printErrMsg(">Error:You attempted to lookup an array but expression is not of type int[].");
        if ( !n.f2.accept(this, argu).equals("int")) {
            printErrMsg(">Error:Offset of array lookup requires int type inisde brackets...");
        }
        return "int";
    }

    /**
     * f0 -> PrimaryExpression()
     * f1 -> "."
     * f2 -> "length"
     */
    public String visit(ArrayLength n, Scope argu) {
        if ( !n.f0.accept(this, argu).equals("int[]") )
            printErrMsg(">Error:You attempted to find the length of an array but symbol is not of type int[].");
        return "int";
    }

    /**
     * f0 -> PrimaryExpression()
     * f1 -> "."
     * f2 -> Identifier()
     * f3 -> "("
     * f4 -> ( ExpressionList() )?
     * f5 -> ")"
     */
    //if receiver and function name are valid, we return the returnType of function even if arg_list is not correct.
    public String visit(MessageSend n, Scope argu) {
        String _ret=null;
        String pr_type = n.f0.accept(this,argu);
        ClassScope classScope = sym.getClassHash(pr_type);
        if ( classScope == null) {
            printErrMsg(">Error:Receiver of method is not a class.");
            return _ret;
        }
        //search all parentclasses to find if the method exists.
        while ( classScope != null) {
            Scope scope = sym.getFuncHash(n.f2.accept(this,null),classScope.getName()); //call Identifier visit with argu=null.
            //we will return the return type of the function even if there was a parse error at the evaluation of arguments.
            if ( scope != null) {
                PairIntScope pairIntScope = new PairIntScope(scope,0);
                scopeStack.push(pairIntScope);
                n.f4.accept(this,argu);
                //check if function signature expects more arguments
                FuncSignature funcSignature = sym.getFuncSignature(pairIntScope.scope);
                if ( funcSignature.getArgType(pairIntScope.argcount) != null)
                    printErrMsg(">Error: Different # of arguments when calling function " + pairIntScope.scope.getName() + " inside " + argu.getName() +  ". Function signature has more arguments (" + funcSignature.getArgSize() + ") than given .");
                //we should pop when done with this call.
                PairIntScope p2 = scopeStack.pop();
                return sym.getReturnType(scope.getName(),classScope.getName());
            }
            classScope = sym.getScopeInheritanceChain(classScope);
        }
        printErrMsg(">Error:Type " + pr_type + " has no method with name " + n.f2.accept(this,null));
        return _ret;
    }

    public boolean parseMethodArg(String expr_type,Scope argu) {
        PairIntScope pairIntScope = scopeStack.peek();
        if (pairIntScope == null)
            printErrMsg("PANIC.stack empty");
        FuncSignature funcSignature = sym.getFuncSignature(pairIntScope.scope);
        String type = funcSignature.getArgType(pairIntScope.argcount);
        if ( type == null) {
            printErrMsg(">Error: Different # of arguments when calling function " + pairIntScope.scope.getName() + " inside " + argu.getName() +  ". Function signature has less arguments (" + funcSignature.getArgSize() + ") than given.");
            pairIntScope.argcount++;
            return false;
        }
        if (expr_type == null || (!type.equals(expr_type) && !(sym.checkSubType(type,expr_type)))) {
            printErrMsg(">Error:Argument types #" + pairIntScope.argcount + " when calling function " + pairIntScope.scope.getName() + " inside " + argu.getName()  + " doesn't match");
        }
        //increment argcount before jumping to the next argument evaluation.
        pairIntScope.argcount++;
        return true;
    }
    /**
     * f0 -> Expression()
     * f1 -> ExpressionTail()
     */
    //use ArrayDeque and store PairIntegerString -> argcount , type_of_first_call.when we enter this func we add a new layer to the Stack.
    //we cant have only one argcount... we need a stack of them.
    public String visit(ExpressionList n, Scope argu) {
        String _ret=null;
        //we dont care if parseMethodArg returns false.
        parseMethodArg(n.f0.accept(this,argu),argu);
        n.f1.accept(this, argu);
        return _ret;
    }

    /**
     * f0 -> ( ExpressionTerm() )*
     */
    public String visit(ExpressionTail n, Scope argu) {
        return n.f0.accept(this, argu);
    }

    /**
     * f0 -> ","
     * f1 -> Expression()
     */
    public String visit(ExpressionTerm n, Scope argu) {
        String _ret=null;
        //we dont care if parseMethodArg returns false.
        parseMethodArg(n.f1.accept(this,argu),argu);
        return _ret;
    }

    /**
     * f0 -> NotExpression()
     *       | PrimaryExpression()
     */
    public String visit(Clause n, Scope argu) {
        return n.f0.accept(this, argu);
    }

    /**
     * f0 -> IntegerLiteral()
     *       | TrueLiteral()
     *       | FalseLiteral()
     *       | Identifier()
     *       | ThisExpression()
     *       | ArrayAllocationExpression()
     *       | AllocationExpression()
     *       | BracketExpression()
     */
    //CHange this..more simple....
    public String visit(PrimaryExpression n, Scope argu) {
        return n.f0.accept(this,argu);
    }

    /**
     * f0 -> <INTEGER_LITERAL>
     */
    public String visit(IntegerLiteral n, Scope argu) {
        return "int";
    }

    /**
     * f0 -> "true"
     */
    public String visit(TrueLiteral n, Scope argu) {
        return "boolean";
    }

    /**
     * f0 -> "false"
     */
    public String visit(FalseLiteral n, Scope argu) {
        return "boolean";
    }

    /**
     * f0 -> <IDENTIFIER>
     */
    public String visit(Identifier n, Scope argu) {
        if ( argu == null) {
            return n.f0.accept(this, argu);
        } else {
            String type =  sym.findType(argu,n.f0.accept(this,argu));
            if ( type == null)
                printErrMsg(">Error: Undeclared identifier " + n.f0.accept(this,argu));
            //System.out.println(n.f0.accept(this, argu));
            return type;
        }
    }

    /**
     * f0 -> "this"
     */
    public String visit(ThisExpression n, Scope argu) {
        //return n.f0.accept(this, argu);
        return sym.getClass(argu);
    }

    /**
     * f0 -> "new"
     * f1 -> "int"
     * f2 -> "["
     * f3 -> Expression()
     * f4 -> "]"
     */
    public String visit(ArrayAllocationExpression n, Scope argu) {
        String _ret=null;
        if ( !n.f3.accept(this, argu).equals("int") ) {
            printErrMsg(">Error:ArrayAllocationExpression requires int type inisde brackets...");
        }
        return "int[]";
    }

    /**
     * f0 -> "new"
     * f1 -> Identifier()
     * f2 -> "("
     * f3 -> ")"
     */
    public String visit(AllocationExpression n, Scope argu) {
        String _ret=null;
        //here ident is type so we call it with argu=null.
        String type =  n.f1.accept(this, null);
        if ( type == null)
            printErrMsg(">Errror:Type " + type + " hasn't been declared");
        return type;
    }

    /**
     * f0 -> "!"
     * f1 -> Clause()
     */
    public String visit(NotExpression n, Scope argu) {
        String _ret=null;
        if ( !n.f1.accept(this, argu).equals("boolean")  )
            printErrMsg(">Error:Unary operator ! followed by non boolean expression");
        return "boolean";
    }

    /**
     * f0 -> "("
     * f1 -> Expression()
     * f2 -> ")"
     */
    public String visit(BracketExpression n, Scope argu) {
        return n.f1.accept(this, argu);
    }

}

class  PairIntScope{
    public Scope scope; //holds current method we are parsing
    public int argcount; //holds current argument we are parsing

    public PairIntScope(Scope scope,int argcount) {
        this.scope = scope;
        this.argcount = argcount;
    }
}
